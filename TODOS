TODOS:



- Use the following presentation on unicode in Python to check gSym over:
    http://farmdev.com/talks/unicode/

- Literate programming style
  1. Define document structure and presentation in another document; a meta-document
  2. The gMeta language should be written as a literate document itself.
  3. The first thing that gSym loads is a view definition of gMeta. Since gMeta is a literate document, gSym will
      have no idea how to find the code that is the gMeta view definition.
  4. The document structure definition must describe how to execute the parts of a document that provide services
      to other documents, and to other parts of the document itself.
  5. Proposal: '$boot' form; gSym should look for a '$boot' form and execute this. This will establish the necessary
      code for executing the gMeta literate document in order to find the gMeta view definition, and the document
      structure view definition, and set these up.
  6. With this in place, the gMeta literate document will be able to be executed and viewed.
  7. PROBLEM: assume that there is one page of the document that collects all the gMeta code together so it can be
      compiled. Various pages throughout the document reference *parts* of this code so that it can be displayed in
      well presented pages. What if a page references part of a where expression (e.g. one bindig) or part of a match
      expression (e.g. a pattern - expression pair)? This poses the problem of how view state is handled.
- For editing languages 'live'; use the smalltalk-ish multiple worlds idea; use one world to edit a hosted world
- Implement web-browser style user interface - urls, tabbed browsing
- Typesetting:
     - Add baseline alignment to DTWrappedLine
     - Provide different hboxes in the view code; an aligned one, and an unaligned one
- Check out the Psyco optimiser, since it works on Linux and Windows.
- GSym will screw up if the system attempts to render two views of the same document node:
     The pattern matcher matches a pattern
     binds one subtree to @a, the other to @b
     ($viewEval @a)
     ($viewEval @b)
     ($viewEval @a)
     Would cause an error, as the second view of @a would cause it to try to recreate the view of @a
- The GLisp compiler should generate memoised lambdas 
- Generate debug information for compiled code
- Handle debug information
- GLisp (compiled to Python) code can generate bad data; check the sanity before processing it
- Ensure that the build contents function can return a DVNode; if it does not generate a widget, this causes an error,
since this widget is passed straight through to the node above/outside


	
	
	

CURSOR HANDLING SYSTEM STATUS:
The cursor handling currently uses the focus system, rather than an ever-present cursor.
It is now handled by the presentation toolkit, rather than by the document view.


ALTERNATE CURSOR MANAGEMENT SYSTEM:
Implement cursor location methods for:
- DTHLine
- DTScript
- DTWrappedLine
- DTWrappedLineWithSeparators
Test cursor location methods for:
- DTBox
- DTEntry




