##-*************************
##-* This program is free software; you can use it, redistribute it and/or modify it
##-* under the terms of the GNU General Public License version 2 as published by the
##-* Free Software Foundation. The full text of the GNU General Public License
##-* version 2 can be found in the file named 'COPYING' that accompanies this
##-* program. This source code is (C)copyright Geoffrey French 1999-2007.
##-*************************

from Britefury.DocModel.DMListInterface import DMListInterface


_stringType = str
_stringTypeSrc = 'str'
_listType = DMListInterface
_listTypeSrc = 'DMListInterface'


class GuardError (Exception):
	pass

def _bind(result, name, value):
	existingValue = result.setdefault( name, value )
	if existingValue is not value:
		raise GuardError
	
		
def _compileGuardList(xs, inputName):
	result = []
	
	varNames = set()

	#detect listRemainderVar
	last = None
	if xs[-1][0] == ':':
		last = -1
		
	#check length
	if last is None:
		#no remainder variable; fixed length
		result.extend( [
			'if len( %s ) != %d:'  %  ( inputName, len( xs ) ),
			'\traise GuardError'
			] )
		
	#guardItem*
	for i, item in enumerate( xs[:last] ):
		itemName = '%s[%d]'  %  ( inputName, i )
		itemSrc, itemVarNames = _compileGuardItem( item, itemName )
		varNames = varNames | itemVarNames
		result.extend( itemSrc )

	#listRemainderVar
	if last == -1:
		result.extend( [ '_bind( result, \'%s\', %s[%d:] )'  %  ( xs[-1][1:], inputName, len( xs ) - 1 ) ] )
		varNames.add( xs[-1][1:] )

	return result, varNames
		

def _compileGuardItem(xs, inputName):
	if isinstance( xs, _listType ):
		guardListSrc, guardListVarNames = _compileGuardList( xs, inputName )
		return [ 'if isinstance( %s, %s ):'  %  ( inputName, _listTypeSrc, ) ]  +  [ '\t' + x   for x in guardListSrc ] + [
			'else:',
			'\traise GuardError'
			], guardListVarNames
	else:
		# constant or var or ignore
		if xs[0] == '!':
			#stringVar
			return [
				'if isinstance( %s, %s ):'  %  ( inputName, _stringTypeSrc ),
				'\t_bind( result, \'%s\', %s )'  %  ( xs[1:], inputName ),
				'else:',
				'\traise GuardError'
			], set( [ xs[1:] ] )
		elif xs[0] == '*':
			#listVar
			return [
				'if isinstance( %s, %s ):'  %  ( inputName, _listTypeSrc ),
				'\t_bind( result, \'%s\', %s )'  %  ( xs[1:], inputName ),
				'else:',
				'\traise GuardError'
			], set( [ xs[1:] ] )
		elif xs[0] == '$':
			#anyVar
			return [ '_bind( result, \'%s\', %s )'  %  ( xs[1:], inputName )
			 ], set( [ xs[1:] ] )
		elif xs == '_':
			#ignore
			return [], set()
		else:
			#constant
			return [
				'if %s != \'%s\':'  %  ( inputName, xs ),
				'\traise GuardError'
			], set()

		
def compileGuardExpression(xs, guardIndirection=[], functionName='guard'):
	"""compileGuardExpression(xs, guardIndirection=[], functionName='guard')   ->   fn, varNames
		xs is a list of guard expressions. It is of type @_listType (normally DMListInterface).
		guardIndirection is a list that specifies the indrection necessary to get the guard expression from each item in xs
		     Examples:
			  (guard0 guard1 ... guardN)    ->     [] (no indirection)
			  ((guard0 action0) (guard1 action1) ... (guardN actionN))     ->    [0] (get the first element of each item)
			  ((? (? ? guard0) ?) (? (? ? guard1) ?) ... (? (? ? guardN) ?))     ->     [1][2] (get the third element of the second element of each item)
		functionName is the name of the python function that will be returned by compileGuardExpression()  (fn.__name__)
		Return values:
		   fn: the function that is generated by compiling the guard expression. It is of the form:
			fn(xs) -> vars, index
			     where:
				  xs: the list to be processed by that guard espression
			     returns:
				  vars: a dictionary mapping variable name (specified in the gaurd expression) to value
				  index: the index of the guard expression that was matched
		   varNames: a list of sets; one for each guard expression. Each set contains the names of the variables generated by the corresponding guard expression
	   
	   
	    Guard expression format:
	   
	    where:
		guardX := guardItem
		guardItem := ignore | constant | var | guardList
		ignore := '_'
		constant := <string>
		var := stringVar | listVar | anyVar
		stringVar := !<name>
		listVar := '*'<name>
		anyVar := '$'<name>
		guardList := (guardItem* listRemainderVar?)
		listRemainderVar := ':'<name>"""
	pySrcHdr = 'def %s(xs):\n'  %  ( functionName, )
	
	if not isinstance( xs, _listType ):
		raise ValueError, 'need a list'
	
	
	result = []
	varNames = []
	for guard in xs:
		for i in guardIndirection:
			guard = guard[i]
		guardItemSrc, guardItemVarNames = _compileGuardItem( guard, 'xs' )
		result.extend( [ 'try:' ] )
		result.extend( [ '\tresult = {}' ] )
		result.extend( [ '\t' + x   for x in guardItemSrc ] )
		result.extend( [ '\treturn result' ] )
		result.extend( [ 'except GuardError:', '\tpass', '' ] )
		varNames.append( guardItemVarNames )
	result.extend( [ 'raise GuardError' ] )
	
	result = [ '\t' + x  for x in result ]
	
	src = pySrcHdr + '\n'.join( result )
	
	lcl = { '_bind' : _bind, 'GuardError' : GuardError, '%s' % ( _listTypeSrc, )  :  _listType }
	
	exec src in lcl
	
	return lcl[functionName], varNames



import unittest
from Britefury.DocModel.DMIO import readSX

class TestCase_GuardExpression (unittest.TestCase):
	def _guardTest(self, guardSrc, dataSrc, expected, indirection=[]):
		if expected is GuardError:
			self.failUnlessRaises( GuardError, lambda: compileGuardExpression( readSX( guardSrc ) )[0]( readSX( dataSrc ) ), )
		else:
			result = compileGuardExpression( readSX( guardSrc ), indirection )[0]( readSX( dataSrc ) )
			self.assert_( result == expected )

	def testEmpty(self):
		self._guardTest( '()', '()', GuardError )

	def testIgnore(self):
		self._guardTest( '(_)', 'a', {} ) 
		self._guardTest( '(_)', 'b', {} ) 
	
	def testConstant(self):
		self._guardTest( '(a)', 'a', {} ) 
		self._guardTest( '(a)', 'b', GuardError ) 
	
	def testStringVar(self):
		self._guardTest( '(!a)', 'test', { 'a' : 'test' } ) 
		self._guardTest( '(!a)', '(a b c)', GuardError ) 

	def testListVar(self):
		self._guardTest( '(*a)', '(a b c)', { 'a' : ['a', 'b', 'c'] } ) 
		self._guardTest( '(*a)', 'test', GuardError ) 

	def testAnyVar(self):
		self._guardTest( '($a)', 'test', { 'a' : 'test' } ) 
		self._guardTest( '($a)', '(a b c)', { 'a' : ['a', 'b', 'c'] } )
		
	def testList(self):
		self._guardTest( '((a b c))', '(a b c)', {} ) 
		self._guardTest( '((a b c))', '(a b c d)', GuardError ) 

	def testListWithVars(self):
		self._guardTest( '((a !foo *bar $doh))', '(a b (c d e) f)', { 'foo' : 'b', 'bar' : [ 'c', 'd', 'e' ], 'doh' : 'f' } ) 
		self._guardTest( '((a !foo *bar $doh))', '(a b (c d e) (f g h))', { 'foo' : 'b', 'bar' : [ 'c', 'd', 'e' ], 'doh' : [ 'f', 'g', 'h' ] } ) 

	def testListRemainder(self):
		self._guardTest( '((a !foo *bar $doh :re))', '(a b (c d e) f g h (i j k) l)', { 'foo' : 'b', 'bar' : [ 'c', 'd', 'e' ], 'doh' : 'f', 're' : [ 'g', 'h', [ 'i', 'j', 'k' ], 'l' ] } )
		self._guardTest( '((a !foo *bar $doh :re))', '(a b (c d e) f g h (i j k) l m)', { 'foo' : 'b', 'bar' : [ 'c', 'd', 'e' ], 'doh' : 'f', 're' : [ 'g', 'h', [ 'i', 'j', 'k' ], 'l', 'm' ] } )
		
	def testMultiBind(self):
		self._guardTest( '((a !foo (x y !foo z w)))', '(a b (x y b z w))', { 'foo' : 'b' } )
		self._guardTest( '((a !foo (x y !foo z w)))', '(a b (x y q z w))', GuardError )
		
	def testMultiGuard(self):
		self._guardTest( '((a !a) (b !b) (c !c) (d !d))', '(a x)', { 'a' : 'x' } )
		self._guardTest( '((a !a) (b !b) (c !c) (d !d))', '(b x)', { 'b' : 'x' } )
		self._guardTest( '((a !a) (b !b) (c !c) (d !d))', '(c x)', { 'c' : 'x' } )
		self._guardTest( '((a !a) (b !b) (c !c) (d !d))', '(d x)', { 'd' : 'x' } )
		self._guardTest( '((a !a) (b !b) (c !c) (d !d))', '(e x)', GuardError )
		
	def testIndirection(self):
		self._guardTest( '(((a !a)) ((b !b)))', '(a x)', { 'a' : 'x' }, [0] )
		
	def testVarNames(self):
		result = compileGuardExpression( readSX( '((a !foo *bar $doh :re))' ) )[1]
		self.assert_( result[0] == set( [ 'foo', 'bar', 'doh', 're' ] ) )



if __name__ == '__main__':
	unittest.main()
