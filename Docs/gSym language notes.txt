DESIGNING LANGUAGES FOR GSYM



Use a different part of your parser for viewing different nodes. This parser can be passed as the state (third) parameter to the viewEval()
function. This will be passed to the inner node 
There are times when you wish to allow a node view to contain data which is more than just an expression.
Example:
	- Python call arguments; can be:
		- <expression>
		- <name>=<expression>
		- *<expression>
		- **<expression>
	- Python subscripts; can be:
		- expression[expression]
		- expression[expression:expression]
	In the second case, starting with the code x[a], attempting to change the 'a' to 'a:b' will not parse,
	if expression[expression] and expression[expression:expression] are parsed by different component parsers.
	In order to make it work correctly; this grammar must be refactored to:
		subscript := expression[subscriptIndex]
		subscriptIndex := subscriptSlice | expression
		subscriptSlice = expression ':' expression
	And the subscruptIndex parser must be used in the view to parse the subscrupt index view nodes.
	This is done by having the view for a subscript node view pass this parser as the state (third) parameter of viewEval() function.
	This parser will be passed through to the state parameter of the view method for the subscript index node. This parser
	can then be used to parse any contents that are typed in.


If an Interactor method requires that a node should be selected after the interaction is complete, this document node should be returned.
Each view node definition must use a call to focus() (defined in Britefury.gSym.View.gSymView) to nominate a widget that will be made 'current'
in order to select the view node.